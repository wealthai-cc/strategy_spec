# WebSocket 行情接入 - 集成指南

## 概述

本文档提供将 WebSocket 行情接入功能集成到策略管理系统的详细指南。

## 前置条件

### 1. 安装依赖

```bash
# 在虚拟环境中安装
source venv/bin/activate
pip install -r requirements.txt

# 或单独安装
pip install websocket-client>=1.6.0
```

### 2. 验证安装

```bash
python3 -c "import websocket; print('websocket-client:', websocket.__version__)"
```

## 集成步骤

### 步骤 1: 系统启动时初始化 WebSocket

在策略管理系统启动时，初始化 WebSocket 管理器：

```python
from engine.python_sdk.websocket_manager import get_websocket_manager

def initialize_system():
    """系统初始化函数"""
    # ... 其他初始化代码 ...
    
    # 初始化 WebSocket 管理器
    manager = get_websocket_manager()
    
    # 从配置文件或环境变量读取配置
    config = load_websocket_config()  # 你的配置加载函数
    
    manager.configure(
        endpoint=config.get('endpoint'),
        csrf_token=config.get('csrf_token'),
        market_type=config.get('market_type', 'binance-testnet'),
        symbols=config.get('symbols', []),
        resolutions=config.get('resolutions', [])
    )
    
    # 启动 WebSocket 连接
    try:
        manager.start()
        logger.info("WebSocket market data service started")
    except Exception as e:
        logger.error(f"Failed to start WebSocket: {e}")
        # 系统可以继续运行，策略将使用 Context 数据
```

### 步骤 2: 根据策略需求配置订阅

当启动策略时，根据策略需求配置订阅：

```python
def start_strategy(strategy_id, config):
    """启动策略"""
    # 获取策略需要的交易对和周期
    symbols = config.get('symbols', [])
    resolutions = config.get('resolutions', ['1h'])
    
    # 更新 WebSocket 订阅
    manager = get_websocket_manager()
    
    # 获取当前订阅
    current_status = manager.get_status()
    current_symbols = set(current_status.get('symbols', []))
    current_resolutions = set(current_status.get('resolutions', []))
    
    # 合并订阅
    new_symbols = list(current_symbols | set(symbols))
    new_resolutions = list(current_resolutions | set(resolutions))
    
    # 更新订阅
    if manager.is_connected():
        manager.update_subscription(new_symbols, new_resolutions)
    else:
        # 如果未连接，重新配置并启动
        manager.configure(
            symbols=new_symbols,
            resolutions=new_resolutions
        )
        manager.start()
    
    # ... 启动策略的其他代码 ...
```

### 步骤 3: 监控 WebSocket 状态

定期检查 WebSocket 连接状态：

```python
import threading
import time

def monitor_websocket():
    """监控 WebSocket 连接状态"""
    manager = get_websocket_manager()
    
    while True:
        status = manager.get_status()
        
        if status['state'] == 'error':
            logger.error(f"WebSocket error: {status.get('last_error')}")
            # 可以尝试重启
            try:
                manager.stop()
                manager.start()
            except Exception as e:
                logger.error(f"Failed to restart WebSocket: {e}")
        
        time.sleep(60)  # 每分钟检查一次

# 在后台线程中运行监控
monitor_thread = threading.Thread(target=monitor_websocket, daemon=True)
monitor_thread.start()
```

### 步骤 4: 系统关闭时清理

在系统关闭时，正确关闭 WebSocket 连接：

```python
def shutdown_system():
    """系统关闭函数"""
    # ... 其他清理代码 ...
    
    # 关闭 WebSocket 连接
    manager = get_websocket_manager()
    manager.stop()
    logger.info("WebSocket market data service stopped")
```

## 配置管理

### 方式 1: 环境变量

```bash
export WEBSOCKET_ENDPOINT="wss://ws.wealthai.cc:18000/market_data"
export WEBSOCKET_CSRF_TOKEN="your_token"
export WEBSOCKET_MARKET_TYPE="binance-testnet"
export WEBSOCKET_SYMBOLS="BTCUSDT,ETHUSDT"
export WEBSOCKET_RESOLUTIONS="1m,5m,1h"
```

### 方式 2: 配置文件

创建 `config/websocket.yaml`:

```yaml
websocket:
  endpoint: "wss://ws.wealthai.cc:18000/market_data"
  csrf_token: "your_token"
  market_type: "binance-testnet"
  symbols:
    - "BTCUSDT"
    - "ETHUSDT"
  resolutions:
    - "1m"
    - "5m"
    - "1h"
```

加载配置：

```python
import yaml

def load_websocket_config():
    with open('config/websocket.yaml', 'r') as f:
        config = yaml.safe_load(f)
    return config.get('websocket', {})
```

### 方式 3: 数据库配置

从数据库读取配置：

```python
def load_websocket_config_from_db():
    # 从数据库读取配置
    config = db.get_config('websocket')
    return config
```

## 策略执行流程

### 正常流程

1. **系统启动**
   - 初始化 WebSocket 管理器
   - 配置并启动 WebSocket 连接
   - 开始接收实时数据并存储到缓存

2. **策略执行**
   - 策略调用 `wealthdata.get_price()`
   - 数据适配器优先从 WebSocket 缓存读取
   - 如果没有，从 Context 读取（回测场景）

3. **数据更新**
   - WebSocket 持续接收新数据
   - 自动更新缓存
   - 策略下次调用时获取最新数据

### 异常处理

1. **WebSocket 连接失败**
   - 系统记录错误日志
   - 策略自动回退到 Context 数据
   - 不影响策略执行

2. **网络断开**
   - WebSocket 客户端自动重连
   - 重连成功后自动重新订阅
   - 策略继续正常工作

3. **数据缺失**
   - 如果 WebSocket 缓存中没有数据
   - 自动从 Context 获取
   - 保证策略始终有数据可用

## 监控和告警

### 监控指标

```python
def get_websocket_metrics():
    """获取 WebSocket 监控指标"""
    manager = get_websocket_manager()
    status = manager.get_status()
    cache = get_websocket_cache()
    
    return {
        'connection_state': status['state'],
        'subscribed_symbols': len(status['symbols']),
        'subscribed_resolutions': len(status['resolutions']),
        'cached_symbols': len(cache.get_cached_symbols()),
        'total_cached_bars': cache.get_cache_size(),
        'last_error': status.get('last_error'),
    }
```

### 告警规则

```python
def check_websocket_health():
    """检查 WebSocket 健康状态"""
    manager = get_websocket_manager()
    status = manager.get_status()
    
    # 告警条件
    if status['state'] == 'error':
        send_alert("WebSocket connection error", status.get('last_error'))
    
    if status['state'] == 'disconnected':
        send_alert("WebSocket disconnected", "Connection lost")
    
    # 检查数据更新
    cache = get_websocket_cache()
    for symbol, timeframe in cache.get_cached_symbols():
        last_update = cache.get_last_update_time(symbol, timeframe)
        if last_update:
            age = time.time() * 1000 - last_update
            if age > 60000:  # 超过 1 分钟没有更新
                send_alert(f"Data stale: {symbol} {timeframe}", f"Last update: {age}ms ago")
```

## 性能优化建议

### 1. 缓存大小调优

根据内存情况调整缓存大小：

```python
from engine.python_sdk.websocket_cache import WebSocketCache, set_websocket_cache

# 创建自定义大小的缓存
cache = WebSocketCache(max_bars_per_symbol=500)  # 减少到 500
set_websocket_cache(cache)
```

### 2. 订阅优化

只订阅策略实际需要的交易对和周期：

```python
# 收集所有策略的需求
all_symbols = set()
all_resolutions = set()

for strategy in active_strategies:
    all_symbols.update(strategy.config.get('symbols', []))
    all_resolutions.update(strategy.config.get('resolutions', []))

# 统一订阅
manager.update_subscription(list(all_symbols), list(all_resolutions))
```

### 3. 连接池管理

如果需要支持多个市场或端点，可以创建多个管理器实例。

## 故障排查

### 问题 1: WebSocket 无法连接

**检查项**:
- 网络连接是否正常
- 端点 URL 是否正确
- CSRF token 是否有效
- 防火墙是否阻止连接

**解决方案**:
```python
# 检查连接状态
status = manager.get_status()
print(f"State: {status['state']}")
print(f"Error: {status.get('last_error')}")

# 尝试重新连接
manager.stop()
manager.start()
```

### 问题 2: 数据未更新

**检查项**:
- WebSocket 是否已连接
- 订阅列表是否正确
- 缓存中是否有数据

**解决方案**:
```python
# 检查缓存
cache = get_websocket_cache()
cached = cache.get_cached_symbols()
print(f"Cached symbols: {cached}")

# 检查特定数据
bars = cache.get_bars("BTCUSDT", "1h")
print(f"Bars count: {len(bars)}")
```

### 问题 3: 策略获取不到数据

**检查项**:
- 数据适配器是否正确注册
- Context 中是否有数据
- WebSocket 缓存中是否有数据

**解决方案**:
```python
# 检查数据适配器
from engine.python_sdk.data_adapter import get_data_adapter
adapter = get_data_adapter()

# 测试获取数据
bars = adapter.get_history("BTCUSDT", 20, "1h")
print(f"Got {len(bars)} bars")
```

## 测试清单

集成前测试：

- [ ] WebSocket 连接测试
- [ ] 数据接收测试
- [ ] 自动重连测试
- [ ] 多策略并发测试
- [ ] 性能测试
- [ ] 故障恢复测试

## 回滚方案

如果集成后出现问题，可以快速回滚：

```python
# 禁用 WebSocket，策略将只使用 Context 数据
manager.stop()

# 或完全移除 WebSocket 功能
# 策略会自动回退到 Context 数据，无需修改策略代码
```

## 总结

WebSocket 行情接入功能设计为**可选功能**，即使 WebSocket 连接失败，策略仍然可以正常工作（使用 Context 数据）。这保证了系统的稳定性和可靠性。

