# 策略开发快速开始指南

> 本指南帮助开发者快速上手编写 Python 策略，参考 JoinQuant 平台的开发体验。

## 快速开始

### 1. 创建策略文件

创建一个 Python 文件（如 `my_strategy.py`），包含生命周期函数：

```python
# my_strategy.py

def initialize(context):
    """策略初始化"""
    context.symbol = "BTCUSDT"
    context.ma_period = 20
    context.quantity = 0.1

def handle_bar(context, bar):
    """处理新 K 线数据"""
    # 获取历史数据
    ma = context.history(context.symbol, context.ma_period, "1h")
    
    # 简单的移动平均策略
    if len(ma) >= context.ma_period:
        current_price = float(bar.close)
        ma_value = sum([float(b.close) for b in ma[-context.ma_period:]]) / context.ma_period
        
        if current_price > ma_value:
            # 价格高于均线，买入
            context.order_buy(context.symbol, context.quantity)
        elif current_price < ma_value:
            # 价格低于均线，卖出
            context.order_sell(context.symbol, context.quantity)
```

### 2. 生命周期函数说明

#### initialize(context) - 必需

策略初始化函数，在策略首次加载时调用一次：

```python
def initialize(context):
    # 设置策略参数
    context.symbol = "BTCUSDT"
    context.ma_period = 20
    
    # 从策略参数中读取配置
    if "ma_period" in context.params:
        context.ma_period = int(context.params["ma_period"])
```

#### handle_bar(context, bar) - 可选

处理新 K 线数据，当行情触发时调用：

```python
def handle_bar(context, bar):
    # bar 包含最新的 K 线数据
    # bar.open, bar.high, bar.low, bar.close, bar.volume
    
    # 获取历史数据
    history = context.history(context.symbol, 20, "1h")
    
    # 策略逻辑
    # ...
```

#### on_order(context, order) - 可选

处理订单状态变更：

```python
def on_order(context, order):
    if order.status == "FILLED":
        print(f"订单成交: {order.order_id}")
    elif order.status == "CANCELED":
        print(f"订单取消: {order.order_id}")
```

#### on_risk_event(context, event) - 可选

处理风控事件：

```python
def on_risk_event(context, event):
    if context.account.risk_level > 80:
        # 风险度过高，减仓
        for position in context.account.positions:
            if position.symbol == context.symbol:
                reduce_qty = position.quantity * 0.5
                context.order_sell(context.symbol, reduce_qty)
```

### 3. Context 对象使用

#### 访问账户信息

```python
# 账户余额
usdt_balance = None
for balance in context.account.balances:
    if balance.free.currency_type == "USDT_CURRENCY_TYPE":
        usdt_balance = balance.free.amount
        break

# 持仓信息
for position in context.account.positions:
    if position.symbol == "BTCUSDT":
        print(f"持仓: {position.quantity}, 成本价: {position.average_cost_price.amount}")

# 风控指标
risk_level = context.account.risk_level
margin_ratio = context.account.margin_ratio
```

#### 获取历史数据

```python
# 获取最近 20 根 1 小时 K 线
bars = context.history("BTCUSDT", 20, "1h")

# 获取最近 10 根日线
daily_bars = context.history("BTCUSDT", 10, "1d")

# 遍历历史数据
for bar in bars:
    print(f"时间: {bar.close_time}, 收盘价: {bar.close}")
```

#### 下单操作

```python
# 限价买入
context.order_buy("BTCUSDT", 0.1, price=42000.0)

# 市价买入（不指定价格）
context.order_buy("BTCUSDT", 0.1)

# 限价卖出
context.order_sell("BTCUSDT", 0.1, price=43000.0)

# 撤销订单
context.cancel_order("order_123")
```

### 4. 完整示例

```python
# ma_strategy.py - 移动平均策略

def initialize(context):
    """策略初始化"""
    context.symbol = "BTCUSDT"
    context.ma_short = 5
    context.ma_long = 20
    context.quantity = 0.1
    
    # 从参数读取配置
    if "ma_short" in context.params:
        context.ma_short = int(context.params["ma_short"])
    if "ma_long" in context.params:
        context.ma_long = int(context.params["ma_long"])

def handle_bar(context, bar):
    """处理 K 线数据"""
    # 获取历史数据
    short_ma = context.history(context.symbol, context.ma_short, "1h")
    long_ma = context.history(context.symbol, context.ma_long, "1h")
    
    if len(short_ma) < context.ma_short or len(long_ma) < context.ma_long:
        return  # 数据不足
    
    # 计算均线值
    short_ma_value = sum([float(b.close) for b in short_ma[-context.ma_short:]]) / context.ma_short
    long_ma_value = sum([float(b.close) for b in long_ma[-context.ma_long:]]) / context.ma_long
    
    current_price = float(bar.close)
    
    # 金叉买入，死叉卖出
    if short_ma_value > long_ma_value:
        # 检查是否已有买单
        has_buy = any(
            o.direction_type == "BUY" and o.status in ["NEW", "PARTIALLY_FILLED"]
            for o in context.account.incomplete_orders
        )
        if not has_buy:
            context.order_buy(context.symbol, context.quantity, price=current_price)
    elif short_ma_value < long_ma_value:
        # 检查是否已有卖单
        has_sell = any(
            o.direction_type == "SELL" and o.status in ["NEW", "PARTIALLY_FILLED"]
            for o in context.account.incomplete_orders
        )
        if not has_sell:
            context.order_sell(context.symbol, context.quantity, price=current_price)

def on_order(context, order):
    """处理订单状态变更"""
    if order.status == "FILLED":
        print(f"订单成交: {order.order_id}, 成交价: {order.avg_fill_price.amount}")
    elif order.status == "CANCELED":
        print(f"订单取消: {order.order_id}, 原因: {order.cancel_reason}")

def on_risk_event(context, event):
    """处理风控事件"""
    if context.account.risk_level > 80:
        print(f"风险度过高: {context.account.risk_level}%, 开始减仓")
        for position in context.account.positions:
            if position.symbol == context.symbol:
                reduce_qty = position.quantity * 0.5
                context.order_sell(context.symbol, reduce_qty)
```

## 常见问题

### Q: 如何获取技术指标？

**A**: 技术指标（MA、EMA 等）通过 `context.history()` 返回的 Bar 数据中包含。也可以自己计算：

```python
def calculate_ma(bars, period):
    """计算移动平均"""
    if len(bars) < period:
        return None
    closes = [float(b.close) for b in bars[-period:]]
    return sum(closes) / period

bars = context.history("BTCUSDT", 20, "1h")
ma20 = calculate_ma(bars, 20)
```

### Q: 如何设置止损？

**A**: 在订单成交后设置止损单：

```python
def on_order(context, order):
    if order.status == "FILLED" and order.direction_type == "BUY":
        # 买入成交，设置 2% 止损
        stop_price = float(order.avg_fill_price.amount) * 0.98
        context.order_sell(
            context.symbol,
            order.executed_size,
            price=stop_price
        )
```

### Q: 如何检查账户余额？

**A**: 通过 `context.account.balances` 访问：

```python
def check_balance(context, currency_type="USDT_CURRENCY_TYPE"):
    for balance in context.account.balances:
        if balance.free.currency_type == currency_type:
            return balance.free.amount
    return 0.0

available = check_balance(context)
if available < 1000:
    print("余额不足")
```

### Q: 策略参数如何传递？

**A**: 通过 `context.params` 访问，参数在策略管理系统中配置：

```python
def initialize(context):
    # 从参数读取配置
    context.symbol = context.params.get("symbol", "BTCUSDT")
    context.ma_period = int(context.params.get("ma_period", "20"))
    context.quantity = float(context.params.get("quantity", "0.1"))
```

## 下一步

- 查看 [策略开发规范](../openspec/specs/strategy-development/spec.md) 了解完整的 API 文档
- 查看 [策略执行引擎规范](../openspec/specs/strategy-engine/spec.md) 了解引擎架构
- 查看 [账户与持仓规范](../openspec/specs/account/spec.md) 了解账户数据结构
- 查看 [订单管理规范](../openspec/specs/order/spec.md) 了解订单操作

---

**相关文档**：
- [策略开发规范](../openspec/specs/strategy-development/spec.md) - 完整的开发文档
- [策略执行引擎规范](../openspec/specs/strategy-engine/spec.md) - 引擎架构说明

